// -------------------------------------------------------------
// 
// File Name: hdlsrc\NRPolarEncodeHDL\Puncture.v
// Created: 2022-01-15 05:10:41
// 
// Generated by MATLAB 9.8 and HDL Coder 3.16
// 
// -------------------------------------------------------------


// -------------------------------------------------------------
// 
// Module: Puncture
// Source Path: NRPolarEncodeHDL/HDL Algorithm/NR Polar Encoder/configure/shortPunc/Puncture
// Hierarchy Level: 4
// 
// -------------------------------------------------------------

`timescale 1 ns / 1 ns

module Puncture
          (clk,
           reset,
           enb,
           E,
           N,
           indx,
           J,
           puncture_1);


  input   clk;
  input   reset;
  input   enb;
  input   [9:0] E;  // ufix10
  input   [10:0] N;  // ufix11
  input   [9:0] indx;  // ufix10
  input   [9:0] J;  // ufix10
  output  puncture_1;


  reg [9:0] Delay7_out1;  // ufix10
  wire signed [31:0] Subtract_sub_temp;  // sfix32
  wire signed [31:0] Subtract_1;  // sfix32
  wire signed [31:0] Subtract_2;  // sfix32
  wire [8:0] Subtract_out1;  // ufix9
  reg [8:0] Delay6_out1;  // ufix9
  wire [9:0] Less_Than_1_1;  // ufix10
  wire Less_Than_relop1;
  reg [9:0] Delay5_out1;  // ufix10
  wire [21:0] Multiply_mul_temp;  // ufix22_En11
  wire [21:0] Multiply_1;  // ufix22
  wire [21:0] Multiply_2;  // ufix22
  wire [9:0] Multiply_out1;  // ufix10
  reg [9:0] Delay2_out1;  // ufix10
  wire GreaterThanOrEqual_relop1;
  reg  Delay10_out1;
  reg [9:0] Delay4_reg [0:1];  // ufix10 [2]
  wire [9:0] Delay4_reg_next [0:1];  // ufix10 [2]
  wire [9:0] Delay4_out1;  // ufix10
  wire [21:0] Multiply2_mul_temp;  // ufix22_En11
  wire [21:0] Multiply2_1;  // ufix22
  wire [21:0] Multiply2_2;  // ufix22
  wire [9:0] Multiply2_out1;  // ufix10
  reg [9:0] Delay_out1;  // ufix10
  wire [19:0] Multiply1_cast;  // ufix20_En10
  wire [9:0] Multiply1_out1;  // ufix10_En1
  wire [19:0] Multiply3_cast;  // ufix20_En11
  wire [9:0] Multiply3_out1;  // ufix10_En2
  reg [9:0] Delay1_out1;  // ufix10_En2
  wire signed [31:0] Subtract2_sub_cast;  // sfix32_En2
  wire signed [31:0] Subtract2_sub_cast_1;  // sfix32_En2
  wire signed [31:0] Subtract2_sub_temp;  // sfix32_En2
  wire [8:0] Subtract2_out1;  // ufix9
  reg [8:0] Delay9_out1;  // ufix9
  wire [9:0] Less_Than2_1_1;  // ufix10
  wire Less_Than2_relop1;
  reg [9:0] Delay3_out1;  // ufix10_En1
  wire signed [31:0] Subtract1_sub_cast;  // sfix32_En1
  wire signed [31:0] Subtract1_sub_cast_1;  // sfix32_En1
  wire signed [31:0] Subtract1_sub_temp;  // sfix32_En1
  wire [8:0] Subtract1_out1;  // ufix9
  reg [8:0] Delay8_out1;  // ufix9
  reg  Delay11_out1;
  wire [9:0] Less_Than1_1_1;  // ufix10
  wire Less_Than1_relop1;
  wire Multiport_Switch1_out1;
  wire OR_out1;
  reg  Delay12_out1;


  always @(posedge clk or posedge reset)
    begin : Delay7_process
      if (reset == 1'b1) begin
        Delay7_out1 <= 10'b0000000000;
      end
      else begin
        if (enb) begin
          Delay7_out1 <= indx;
        end
      end
    end



  assign Subtract_1 = {21'b0, N};
  assign Subtract_2 = {22'b0, E};
  assign Subtract_sub_temp = Subtract_1 - Subtract_2;
  assign Subtract_out1 = Subtract_sub_temp[8:0];



  always @(posedge clk or posedge reset)
    begin : Delay6_process
      if (reset == 1'b1) begin
        Delay6_out1 <= 9'b000000000;
      end
      else begin
        if (enb) begin
          Delay6_out1 <= Subtract_out1;
        end
      end
    end



  assign Less_Than_1_1 = {1'b0, Delay6_out1};
  assign Less_Than_relop1 = Delay7_out1 < Less_Than_1_1;



  always @(posedge clk or posedge reset)
    begin : Delay5_process
      if (reset == 1'b1) begin
        Delay5_out1 <= 10'b0000000000;
      end
      else begin
        if (enb) begin
          Delay5_out1 <= E;
        end
      end
    end



  // CSD Encoding (1536) : 011000000000; Cost (Adders) = 1
  assign Multiply_1 = {1'b0, {N, 10'b0000000000}};
  assign Multiply_2 = {2'b0, {N, 9'b000000000}};
  assign Multiply_mul_temp = Multiply_1 + Multiply_2;
  assign Multiply_out1 = Multiply_mul_temp[20:11];



  always @(posedge clk or posedge reset)
    begin : Delay2_process
      if (reset == 1'b1) begin
        Delay2_out1 <= 10'b0000000000;
      end
      else begin
        if (enb) begin
          Delay2_out1 <= Multiply_out1;
        end
      end
    end



  assign GreaterThanOrEqual_relop1 = Delay5_out1 >= Delay2_out1;



  always @(posedge clk or posedge reset)
    begin : Delay10_process
      if (reset == 1'b1) begin
        Delay10_out1 <= 1'b0;
      end
      else begin
        if (enb) begin
          Delay10_out1 <= GreaterThanOrEqual_relop1;
        end
      end
    end



  always @(posedge clk or posedge reset)
    begin : Delay4_process
      if (reset == 1'b1) begin
        Delay4_reg[0] <= 10'b0000000000;
        Delay4_reg[1] <= 10'b0000000000;
      end
      else begin
        if (enb) begin
          Delay4_reg[0] <= Delay4_reg_next[0];
          Delay4_reg[1] <= Delay4_reg_next[1];
        end
      end
    end

  assign Delay4_out1 = Delay4_reg[1];
  assign Delay4_reg_next[0] = J;
  assign Delay4_reg_next[1] = Delay4_reg[0];



  // CSD Encoding (1152) : 010010000000; Cost (Adders) = 1
  assign Multiply2_1 = {1'b0, {N, 10'b0000000000}};
  assign Multiply2_2 = {4'b0, {N, 7'b0000000}};
  assign Multiply2_mul_temp = Multiply2_1 + Multiply2_2;
  assign Multiply2_out1 = Multiply2_mul_temp[20:11];



  always @(posedge clk or posedge reset)
    begin : Delay_process
      if (reset == 1'b1) begin
        Delay_out1 <= 10'b0000000000;
      end
      else begin
        if (enb) begin
          Delay_out1 <= Multiply2_out1;
        end
      end
    end



  assign Multiply1_cast = {1'b0, {E, 9'b000000000}};
  assign Multiply1_out1 = Multiply1_cast[18:9];



  assign Multiply3_cast = {1'b0, {Multiply1_out1, 9'b000000000}};
  assign Multiply3_out1 = Multiply3_cast[18:9];



  always @(posedge clk or posedge reset)
    begin : Delay1_process
      if (reset == 1'b1) begin
        Delay1_out1 <= 10'b0000000000;
      end
      else begin
        if (enb) begin
          Delay1_out1 <= Multiply3_out1;
        end
      end
    end



  assign Subtract2_sub_cast = {20'b0, {Delay_out1, 2'b00}};
  assign Subtract2_sub_cast_1 = {22'b0, Delay1_out1};
  assign Subtract2_sub_temp = Subtract2_sub_cast - Subtract2_sub_cast_1;
  assign Subtract2_out1 = Subtract2_sub_temp[10:2] + (|Subtract2_sub_temp[1:0]);



  always @(posedge clk or posedge reset)
    begin : Delay9_process
      if (reset == 1'b1) begin
        Delay9_out1 <= 9'b000000000;
      end
      else begin
        if (enb) begin
          Delay9_out1 <= Subtract2_out1;
        end
      end
    end



  assign Less_Than2_1_1 = {1'b0, Delay9_out1};
  assign Less_Than2_relop1 = Delay4_out1 < Less_Than2_1_1;



  always @(posedge clk or posedge reset)
    begin : Delay3_process
      if (reset == 1'b1) begin
        Delay3_out1 <= 10'b0000000000;
      end
      else begin
        if (enb) begin
          Delay3_out1 <= Multiply1_out1;
        end
      end
    end



  assign Subtract1_sub_cast = {21'b0, {Delay2_out1, 1'b0}};
  assign Subtract1_sub_cast_1 = {22'b0, Delay3_out1};
  assign Subtract1_sub_temp = Subtract1_sub_cast - Subtract1_sub_cast_1;
  assign Subtract1_out1 = Subtract1_sub_temp[9:1] + Subtract1_sub_temp[0];



  always @(posedge clk or posedge reset)
    begin : Delay8_process
      if (reset == 1'b1) begin
        Delay8_out1 <= 9'b000000000;
      end
      else begin
        if (enb) begin
          Delay8_out1 <= Subtract1_out1;
        end
      end
    end



  always @(posedge clk or posedge reset)
    begin : Delay11_process
      if (reset == 1'b1) begin
        Delay11_out1 <= 1'b0;
      end
      else begin
        if (enb) begin
          Delay11_out1 <= Less_Than_relop1;
        end
      end
    end



  assign Less_Than1_1_1 = {1'b0, Delay8_out1};
  assign Less_Than1_relop1 = Delay4_out1 < Less_Than1_1_1;



  assign Multiport_Switch1_out1 = (Delay10_out1 == 1'b0 ? Less_Than2_relop1 :
              Less_Than1_relop1);



  assign OR_out1 = Delay11_out1 | Multiport_Switch1_out1;



  always @(posedge clk or posedge reset)
    begin : Delay12_process
      if (reset == 1'b1) begin
        Delay12_out1 <= 1'b0;
      end
      else begin
        if (enb) begin
          Delay12_out1 <= OR_out1;
        end
      end
    end



  assign puncture_1 = Delay12_out1;

endmodule  // Puncture

