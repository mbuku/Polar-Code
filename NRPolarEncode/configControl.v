// -------------------------------------------------------------
// 
// File Name: hdlsrc\NRPolarEncodeHDL\configControl.v
// Created: 2022-01-15 05:10:41
// 
// Generated by MATLAB 9.8 and HDL Coder 3.16
// 
// -------------------------------------------------------------


// -------------------------------------------------------------
// 
// Module: configControl
// Source Path: NRPolarEncodeHDL/HDL Algorithm/NR Polar Encoder/configure/configControl
// Hierarchy Level: 3
// 
// -------------------------------------------------------------

`timescale 1 ns / 1 ns

module configControl
          (clk,
           reset,
           enb,
           start,
           rateLT,
           N,
           configured,
           idx,
           enItlvMap,
           enSequence,
           rstSequence,
           enSP);


  input   clk;
  input   reset;
  input   enb;
  input   start;
  input   rateLT;
  input   [9:0] N;  // ufix10
  output  configured;
  output  [9:0] idx;  // ufix10
  output  enItlvMap;
  output  enSequence;
  output  rstSequence;
  output  enSP;


  reg  configured_1;
  reg [9:0] idx_1;  // ufix10
  reg  enItlvMap_1;
  reg  enSequence_1;
  reg  rstSequence_1;
  reg  enSP_1;
  reg [1:0] reg_state;  // ufix2
  reg [9:0] reg_idx;  // ufix10
  reg  reg_enSequence;
  reg  reg_rstSequence;
  reg  reg_enItlvMap;
  reg [1:0] reg_state_next;  // ufix2
  reg [9:0] reg_idx_next;  // ufix10
  reg  reg_enSequence_next;
  reg  reg_rstSequence_next;
  reg  reg_enItlvMap_next;
  reg  next_enSequence;
  reg [10:0] add_temp;  // ufix11
  reg [10:0] add_temp_0;  // ufix11
  reg [10:0] t_0;  // ufix11
  reg [10:0] t_1;  // ufix11


  always @(posedge clk or posedge reset)
    begin : whdledac_c11_configControl_process
      if (reset == 1'b1) begin
        reg_state <= 2'b00;
        reg_idx <= 10'b0000000000;
        reg_enSequence <= 1'b0;
        reg_rstSequence <= 1'b0;
        reg_enItlvMap <= 1'b0;
      end
      else begin
        if (enb) begin
          reg_state <= reg_state_next;
          reg_idx <= reg_idx_next;
          reg_enSequence <= reg_enSequence_next;
          reg_rstSequence <= reg_rstSequence_next;
          reg_enItlvMap <= reg_enItlvMap_next;
        end
      end
    end

  always @(N, rateLT, reg_enItlvMap, reg_enSequence, reg_idx, reg_rstSequence, reg_state,
       start) begin
    add_temp = 11'b00000000000;
    add_temp_0 = 11'b00000000000;
    t_0 = 11'b00000000000;
    t_1 = 11'b00000000000;
    reg_state_next = reg_state;
    reg_idx_next = reg_idx;
    next_enSequence = reg_enSequence;
    reg_rstSequence_next = reg_rstSequence;
    if (reg_rstSequence) begin
      reg_rstSequence_next = 1'b0;
    end
    case ( reg_state)
      2'b00 :
        begin
          //only run if the main controller triggers a reconfigure
          if (start) begin
            //if E < N we need to compute the indices to block due to
            //shortening and puncturing
            if (rateLT) begin
              reg_state_next = 2'b01;
            end
            else begin
              reg_state_next = 2'b10;
              next_enSequence = 1'b1;
              reg_rstSequence_next = 1'b1;
              //Downlink mode requires the input interleaving map to
              //be generated
            end
          end
        end
      2'b01 :
        begin
          //compute indices that will b e removed by
          //shoertening/puncturing
          if (start) begin
            reg_idx_next = 10'b0000000000;
            //if E < N we need to compute the indices to block due to
            //shortening and puncturing
            if (rateLT) begin
              reg_state_next = 2'b01;
            end
            else begin
              reg_state_next = 2'b10;
              next_enSequence = 1'b1;
              reg_rstSequence_next = 1'b1;
              //Downlink mode requires the input interleaving map to
              //be generated
            end
          end
          else if (reg_idx == N) begin
            reg_state_next = 2'b10;
            next_enSequence = 1'b1;
            reg_rstSequence_next = 1'b1;
            reg_idx_next = 10'b0000000000;
          end
          else begin
            t_0 = {1'b0, reg_idx};
            add_temp = t_0 + 11'b00000000001;
            if (add_temp[10] != 1'b0) begin
              reg_idx_next = 10'b1111111111;
            end
            else begin
              reg_idx_next = add_temp[9:0];
            end
          end
        end
      2'b10 :
        begin
          //compute the encode sequence to map the msg onto the most
          //reliable bits in the output
          if (start) begin
            reg_idx_next = 10'b0000000000;
            //if E < N we need to compute the indices to block due to
            //shortening and puncturing
            if (rateLT) begin
              reg_state_next = 2'b01;
            end
            else begin
              reg_state_next = 2'b10;
              next_enSequence = 1'b1;
              reg_rstSequence_next = 1'b1;
              //Downlink mode requires the input interleaving map to
              //be generated
            end
          end
          else begin
            if (reg_idx == N) begin
              next_enSequence = 1'b0;
            end
            if (( ! next_enSequence) && ( ! reg_enItlvMap)) begin
              reg_state_next = 2'b00;
              reg_idx_next = 10'b0000000000;
            end
            else begin
              t_1 = {1'b0, reg_idx};
              add_temp_0 = t_1 + 11'b00000000001;
              if (add_temp_0[10] != 1'b0) begin
                reg_idx_next = 10'b1111111111;
              end
              else begin
                reg_idx_next = add_temp_0[9:0];
              end
            end
          end
        end
    endcase
    reg_enSequence_next = next_enSequence;
    reg_enItlvMap_next = reg_enItlvMap;
    configured_1 = reg_state == 2'b00;
    idx_1 = reg_idx;
    enItlvMap_1 = reg_enItlvMap;
    enSequence_1 = reg_enSequence;
    rstSequence_1 = reg_rstSequence;
    enSP_1 = reg_state == 2'b01;
  end



  assign configured = configured_1;

  assign idx = idx_1;

  assign enItlvMap = enItlvMap_1;

  assign enSequence = enSequence_1;

  assign rstSequence = rstSequence_1;

  assign enSP = enSP_1;

endmodule  // configControl

