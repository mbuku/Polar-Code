// -------------------------------------------------------------
// 
// File Name: hdlsrc\NRPolarEncodeHDL\shortPunc.v
// Created: 2022-01-15 05:10:41
// 
// Generated by MATLAB 9.8 and HDL Coder 3.16
// 
// -------------------------------------------------------------


// -------------------------------------------------------------
// 
// Module: shortPunc
// Source Path: NRPolarEncodeHDL/HDL Algorithm/NR Polar Encoder/configure/shortPunc
// Hierarchy Level: 3
// 
// -------------------------------------------------------------

`timescale 1 ns / 1 ns

module shortPunc
          (clk,
           reset,
           enb,
           idx,
           enShortPunc,
           K,
           N,
           n_1,
           E,
           QfWEn,
           remove,
           indxOut);


  input   clk;
  input   reset;
  input   enb;
  input   [9:0] idx;  // ufix10
  input   enShortPunc;
  input   [9:0] K;  // ufix10
  input   [10:0] N;  // ufix11
  input   [7:0] n_1;  // uint8
  input   [9:0] E;  // ufix10
  output  QfWEn;
  output  remove;  // ufix1
  output  [9:0] indxOut;  // ufix10


  reg  [0:5] Delay2_reg;  // ufix1 [6]
  wire [0:5] Delay2_reg_next;  // ufix1 [6]
  wire Delay2_out1;
  wire K_E_7_16_out1;
  reg [9:0] Delay1_reg [0:2];  // ufix10 [3]
  wire [9:0] Delay1_reg_next [0:2];  // ufix10 [3]
  wire [9:0] Delay1_out1;  // ufix10
  wire Shorten_out1;
  wire [9:0] J_calc_out1;  // ufix10
  wire Puncture_out1;
  wire Multiport_Switch_out1;
  wire Cast1_out1;  // ufix1
  reg [9:0] Delay_reg [0:2];  // ufix10 [3]
  wire [9:0] Delay_reg_next [0:2];  // ufix10 [3]
  wire [9:0] Delay_out1;  // ufix10


  always @(posedge clk or posedge reset)
    begin : Delay2_process
      if (reset == 1'b1) begin
        Delay2_reg[0] <= 1'b0;
        Delay2_reg[1] <= 1'b0;
        Delay2_reg[2] <= 1'b0;
        Delay2_reg[3] <= 1'b0;
        Delay2_reg[4] <= 1'b0;
        Delay2_reg[5] <= 1'b0;
      end
      else begin
        if (enb) begin
          Delay2_reg[0] <= Delay2_reg_next[0];
          Delay2_reg[1] <= Delay2_reg_next[1];
          Delay2_reg[2] <= Delay2_reg_next[2];
          Delay2_reg[3] <= Delay2_reg_next[3];
          Delay2_reg[4] <= Delay2_reg_next[4];
          Delay2_reg[5] <= Delay2_reg_next[5];
        end
      end
    end

  assign Delay2_out1 = Delay2_reg[5];
  assign Delay2_reg_next[0] = enShortPunc;
  assign Delay2_reg_next[1] = Delay2_reg[0];
  assign Delay2_reg_next[2] = Delay2_reg[1];
  assign Delay2_reg_next[3] = Delay2_reg[2];
  assign Delay2_reg_next[4] = Delay2_reg[3];
  assign Delay2_reg_next[5] = Delay2_reg[4];



  assign QfWEn = Delay2_out1;

  alpha16 u_K_E_7_16 (.clk(clk),
                      .reset(reset),
                      .enb(enb),
                      .K(K),  // ufix10
                      .E(E),  // ufix10
                      .sel(K_E_7_16_out1)
                      );

  always @(posedge clk or posedge reset)
    begin : Delay1_process
      if (reset == 1'b1) begin
        Delay1_reg[0] <= 10'b0000000000;
        Delay1_reg[1] <= 10'b0000000000;
        Delay1_reg[2] <= 10'b0000000000;
      end
      else begin
        if (enb) begin
          Delay1_reg[0] <= Delay1_reg_next[0];
          Delay1_reg[1] <= Delay1_reg_next[1];
          Delay1_reg[2] <= Delay1_reg_next[2];
        end
      end
    end

  assign Delay1_out1 = Delay1_reg[2];
  assign Delay1_reg_next[0] = idx;
  assign Delay1_reg_next[1] = Delay1_reg[0];
  assign Delay1_reg_next[2] = Delay1_reg[1];



  Shorten u_Shorten (.clk(clk),
                     .reset(reset),
                     .enb(enb),
                     .E(E),  // ufix10
                     .N(N),  // ufix11
                     .Indx(Delay1_out1),  // ufix10
                     .shorten_1(Shorten_out1)
                     );

  J_calc u_J_calc (.clk(clk),
                   .reset(reset),
                   .enb(enb),
                   .idx(idx),  // ufix10
                   .n(n_1),  // uint8
                   .J(J_calc_out1)  // ufix10
                   );

  Puncture u_Puncture (.clk(clk),
                       .reset(reset),
                       .enb(enb),
                       .E(E),  // ufix10
                       .N(N),  // ufix11
                       .indx(Delay1_out1),  // ufix10
                       .J(J_calc_out1),  // ufix10
                       .puncture_1(Puncture_out1)
                       );

  assign Multiport_Switch_out1 = (K_E_7_16_out1 == 1'b0 ? Shorten_out1 :
              Puncture_out1);



  assign Cast1_out1 = Multiport_Switch_out1;



  assign remove = Cast1_out1;

  always @(posedge clk or posedge reset)
    begin : Delay_process
      if (reset == 1'b1) begin
        Delay_reg[0] <= 10'b0000000000;
        Delay_reg[1] <= 10'b0000000000;
        Delay_reg[2] <= 10'b0000000000;
      end
      else begin
        if (enb) begin
          Delay_reg[0] <= Delay_reg_next[0];
          Delay_reg[1] <= Delay_reg_next[1];
          Delay_reg[2] <= Delay_reg_next[2];
        end
      end
    end

  assign Delay_out1 = Delay_reg[2];
  assign Delay_reg_next[0] = J_calc_out1;
  assign Delay_reg_next[1] = Delay_reg[0];
  assign Delay_reg_next[2] = Delay_reg[1];



  assign indxOut = Delay_out1;

endmodule  // shortPunc

