// -------------------------------------------------------------
// 
// File Name: hdlsrc\NRPolarDecodeHDL\CRCGenControl.v
// Created: 2022-01-15 05:13:24
// 
// Generated by MATLAB 9.8 and HDL Coder 3.16
// 
// -------------------------------------------------------------


// -------------------------------------------------------------
// 
// Module: CRCGenControl
// Source Path: NRPolarDecodeHDL/HDL Algorithm/NR Polar Decoder/CRC Decoder/CRCGenerator/CRCGenControl
// Hierarchy Level: 4
// 
// CRC Generator Control Signals Generation
// 
// -------------------------------------------------------------

`timescale 1 ns / 1 ns

module CRCGenControl
          (clk,
           reset,
           enb,
           startIn,
           endIn,
           validIn,
           startOut,
           processMsg,
           padZero,
           outputCRC,
           endOut,
           validOut,
           regClr,
           counter,
           counter_outputCRC);


  input   clk;
  input   reset;
  input   enb;
  input   startIn;  // ufix1
  input   endIn;  // ufix1
  input   validIn;  // ufix1
  output  startOut;  // ufix1
  output  processMsg;  // ufix1
  output  padZero;  // ufix1
  output  outputCRC;  // ufix1
  output  endOut;  // ufix1
  output  validOut;  // ufix1
  output  regClr;  // ufix1
  output  [3:0] counter;  // ufix4
  output  [3:0] counter_outputCRC;  // ufix4


  reg  [0:11] dataOut_register_reg;  // ufix1 [12]
  wire [0:11] dataOut_register_reg_next;  // ufix1 [12]
  reg  validindelay;  // ufix1
  reg  sofindelay;  // ufix1
  reg  eofindelay;  // ufix1
  reg [1:0] CRCControlFSM_FSMNextState;  // ufix2
  reg [4:0] CRCControlFSM_Cnt1;  // ufix5
  reg [3:0] CRCControlFSM_Cnt2;  // ufix4
  reg [3:0] CRCControlFSM_Cnt3;  // ufix4
  reg  CRCControlFSM_Cnt3_enb;
  reg [1:0] CRCControlFSM_FSMNextState_next;  // ufix2
  reg [4:0] CRCControlFSM_Cnt1_next;  // ufix5
  reg [3:0] CRCControlFSM_Cnt2_next;  // ufix4
  reg [3:0] CRCControlFSM_Cnt3_next;  // ufix4
  reg  CRCControlFSM_Cnt3_enb_next;
  reg  validOutTemp;  // ufix1
  reg  endOutTemp;  // ufix1
  reg  validLowFlag;  // ufix1
  reg  outputCRC_1;  // ufix1
  reg  processMsg_1;  // ufix1
  reg  padZero_1;  // ufix1
  reg  regClr_1;  // ufix1
  reg [3:0] counter_1;  // ufix4
  reg [3:0] counter_outputCRC_1;  // ufix4
  reg  [0:10] dataOut_register_reg_1;  // ufix1 [11]
  wire [0:10] dataOut_register_reg_next_1;  // ufix1 [11]
  reg  [0:10] validLowFlag_register_reg;  // ufix1 [11]
  wire [0:10] validLowFlag_register_reg_next;  // ufix1 [11]
  wire validLowFlagDelay;  // ufix1
  reg [3:0] CRCControlFSM_Cnt3_temp;  // ufix4


  // buffer for startOut
  always @(posedge clk or posedge reset)
    begin : dataOut_register_process
      if (reset == 1'b1) begin
        dataOut_register_reg[0] <= 1'b0;
        dataOut_register_reg[1] <= 1'b0;
        dataOut_register_reg[2] <= 1'b0;
        dataOut_register_reg[3] <= 1'b0;
        dataOut_register_reg[4] <= 1'b0;
        dataOut_register_reg[5] <= 1'b0;
        dataOut_register_reg[6] <= 1'b0;
        dataOut_register_reg[7] <= 1'b0;
        dataOut_register_reg[8] <= 1'b0;
        dataOut_register_reg[9] <= 1'b0;
        dataOut_register_reg[10] <= 1'b0;
        dataOut_register_reg[11] <= 1'b0;
      end
      else begin
        if (enb) begin
          dataOut_register_reg[0] <= dataOut_register_reg_next[0];
          dataOut_register_reg[1] <= dataOut_register_reg_next[1];
          dataOut_register_reg[2] <= dataOut_register_reg_next[2];
          dataOut_register_reg[3] <= dataOut_register_reg_next[3];
          dataOut_register_reg[4] <= dataOut_register_reg_next[4];
          dataOut_register_reg[5] <= dataOut_register_reg_next[5];
          dataOut_register_reg[6] <= dataOut_register_reg_next[6];
          dataOut_register_reg[7] <= dataOut_register_reg_next[7];
          dataOut_register_reg[8] <= dataOut_register_reg_next[8];
          dataOut_register_reg[9] <= dataOut_register_reg_next[9];
          dataOut_register_reg[10] <= dataOut_register_reg_next[10];
          dataOut_register_reg[11] <= dataOut_register_reg_next[11];
        end
      end
    end

  assign startOut = dataOut_register_reg[11];
  assign dataOut_register_reg_next[0] = startIn;
  assign dataOut_register_reg_next[1] = dataOut_register_reg[0];
  assign dataOut_register_reg_next[2] = dataOut_register_reg[1];
  assign dataOut_register_reg_next[3] = dataOut_register_reg[2];
  assign dataOut_register_reg_next[4] = dataOut_register_reg[3];
  assign dataOut_register_reg_next[5] = dataOut_register_reg[4];
  assign dataOut_register_reg_next[6] = dataOut_register_reg[5];
  assign dataOut_register_reg_next[7] = dataOut_register_reg[6];
  assign dataOut_register_reg_next[8] = dataOut_register_reg[7];
  assign dataOut_register_reg_next[9] = dataOut_register_reg[8];
  assign dataOut_register_reg_next[10] = dataOut_register_reg[9];
  assign dataOut_register_reg_next[11] = dataOut_register_reg[10];



  // validIn buffer
  always @(posedge clk or posedge reset)
    begin : validInReg_process
      if (reset == 1'b1) begin
        validindelay <= 1'b0;
      end
      else begin
        if (enb) begin
          validindelay <= validIn;
        end
      end
    end



  // startIn buffer
  always @(posedge clk or posedge reset)
    begin : startInReg_process
      if (reset == 1'b1) begin
        sofindelay <= 1'b0;
      end
      else begin
        if (enb) begin
          sofindelay <= startIn;
        end
      end
    end



  // endIn buffer
  always @(posedge clk or posedge reset)
    begin : endInReg_process
      if (reset == 1'b1) begin
        eofindelay <= 1'b0;
      end
      else begin
        if (enb) begin
          eofindelay <= endIn;
        end
      end
    end



  // CRC Generator Control FSM
  always @(posedge clk or posedge reset)
    begin : CRCControlFSM_process
      if (reset == 1'b1) begin
        CRCControlFSM_FSMNextState <= 2'b00;
        CRCControlFSM_Cnt1 <= 5'b00000;
        CRCControlFSM_Cnt2 <= 4'b0000;
        CRCControlFSM_Cnt3 <= 4'b0000;
        CRCControlFSM_Cnt3_enb <= 1'b0;
      end
      else begin
        if (enb) begin
          CRCControlFSM_FSMNextState <= CRCControlFSM_FSMNextState_next;
          CRCControlFSM_Cnt1 <= CRCControlFSM_Cnt1_next;
          CRCControlFSM_Cnt2 <= CRCControlFSM_Cnt2_next;
          CRCControlFSM_Cnt3 <= CRCControlFSM_Cnt3_next;
          CRCControlFSM_Cnt3_enb <= CRCControlFSM_Cnt3_enb_next;
        end
      end
    end

  always @(CRCControlFSM_Cnt1, CRCControlFSM_Cnt2, CRCControlFSM_Cnt3,
       CRCControlFSM_Cnt3_enb, CRCControlFSM_FSMNextState, eofindelay,
       sofindelay, startIn, validIn, validindelay) begin
    CRCControlFSM_Cnt3_temp = CRCControlFSM_Cnt3;
    CRCControlFSM_FSMNextState_next = CRCControlFSM_FSMNextState;
    CRCControlFSM_Cnt1_next = CRCControlFSM_Cnt1;
    CRCControlFSM_Cnt2_next = CRCControlFSM_Cnt2;
    CRCControlFSM_Cnt3_enb_next = CRCControlFSM_Cnt3_enb;
    case ( CRCControlFSM_FSMNextState)
      2'b00 :
        begin
          validLowFlag = 1'b1;
          regClr_1 = 1'b0;
          processMsg_1 = 1'b0;
          padZero_1 = 1'b0;
          endOutTemp = 1'b0;
          if (CRCControlFSM_Cnt3_enb) begin
            validOutTemp = 1'b1;
            outputCRC_1 = 1'b1;
            if (CRCControlFSM_Cnt3 == 4'b1010) begin
              CRCControlFSM_Cnt3_enb_next = 1'b0;
              CRCControlFSM_Cnt3_temp = 4'b0000;
            end
            else begin
              CRCControlFSM_Cnt3_temp = CRCControlFSM_Cnt3 + 4'b0001;
            end
          end
          else begin
            validOutTemp = 1'b0;
            outputCRC_1 = 1'b0;
          end
          if ((validindelay != 1'b0) && (sofindelay != 1'b0)) begin
            processMsg_1 = 1'b1;
          end
          if ((validIn != 1'b0) && (startIn != 1'b0)) begin
            regClr_1 = 1'b1;
            CRCControlFSM_FSMNextState_next = 2'b01;
            CRCControlFSM_Cnt1_next = 5'b00000;
            CRCControlFSM_Cnt2_next = 4'b0000;
          end
          else begin
            CRCControlFSM_FSMNextState_next = 2'b00;
          end
        end
      2'b01 :
        begin
          validLowFlag = 1'b1;
          regClr_1 = 1'b0;
          processMsg_1 = 1'b1;
          endOutTemp = 1'b0;
          padZero_1 = 1'b0;
          CRCControlFSM_Cnt2_next = 4'b0000;
          if (validindelay == 1'b0) begin
            validLowFlag = 1'b0;
          end
          if ((validIn != 1'b0) && (startIn != 1'b0)) begin
            regClr_1 = 1'b1;
            CRCControlFSM_FSMNextState_next = 2'b01;
            CRCControlFSM_Cnt1_next = 5'b00000;
            if (CRCControlFSM_Cnt3_enb) begin
              validOutTemp = 1'b1;
              outputCRC_1 = 1'b1;
              if (CRCControlFSM_Cnt3 == 4'b1010) begin
                CRCControlFSM_Cnt3_enb_next = 1'b0;
                CRCControlFSM_Cnt3_temp = 4'b0000;
              end
              else begin
                CRCControlFSM_Cnt3_temp = CRCControlFSM_Cnt3 + 4'b0001;
              end
            end
            else begin
              validOutTemp = 1'b0;
              outputCRC_1 = 1'b0;
            end
          end
          else begin
            if (CRCControlFSM_Cnt3_enb) begin
              validOutTemp = 1'b1;
              outputCRC_1 = 1'b1;
            end
            else begin
              validOutTemp = CRCControlFSM_Cnt1 == 5'b01011;
              outputCRC_1 = 1'b0;
            end
            if (CRCControlFSM_Cnt3_enb) begin
              if (CRCControlFSM_Cnt3 == 4'b1010) begin
                CRCControlFSM_Cnt3_enb_next = 1'b0;
                CRCControlFSM_Cnt3_temp = 4'b0000;
              end
              else begin
                CRCControlFSM_Cnt3_temp = CRCControlFSM_Cnt3 + 4'b0001;
              end
            end
            if (CRCControlFSM_Cnt1 < 5'b01011) begin
              CRCControlFSM_Cnt1_next = CRCControlFSM_Cnt1 + 5'b00001;
            end
            if ((validindelay != 1'b0) && (eofindelay != 1'b0)) begin
              CRCControlFSM_FSMNextState_next = 2'b10;
            end
            else begin
              CRCControlFSM_FSMNextState_next = 2'b01;
            end
          end
        end
      2'b10 :
        begin
          validLowFlag = 1'b1;
          regClr_1 = 1'b0;
          processMsg_1 = 1'b0;
          padZero_1 = 1'b1;
          if ((validindelay != 1'b0) && (sofindelay != 1'b0)) begin
            processMsg_1 = 1'b1;
          end
          if ((validIn != 1'b0) && (startIn != 1'b0)) begin
            regClr_1 = 1'b1;
            CRCControlFSM_FSMNextState_next = 2'b01;
            CRCControlFSM_Cnt1_next = 5'b00000;
            if (CRCControlFSM_Cnt2 == 4'b1010) begin
              validOutTemp = 1'b1;
              endOutTemp = 1'b1;
              CRCControlFSM_Cnt3_enb_next = 1'b1;
              outputCRC_1 = 1'b0;
              CRCControlFSM_Cnt3_temp = 4'b0000;
              CRCControlFSM_Cnt2_next = 4'b0000;
            end
            else begin
              endOutTemp = 1'b0;
              if (CRCControlFSM_Cnt3_enb) begin
                validOutTemp = 1'b1;
                outputCRC_1 = 1'b1;
                if (CRCControlFSM_Cnt3 == 4'b1010) begin
                  CRCControlFSM_Cnt3_enb_next = 1'b0;
                  CRCControlFSM_Cnt3_temp = 4'b0000;
                end
                CRCControlFSM_Cnt3_temp = CRCControlFSM_Cnt3_temp + 4'b0001;
              end
              else begin
                validOutTemp = 1'b0;
                CRCControlFSM_Cnt2_next = 4'b0000;
                CRCControlFSM_Cnt3_temp = 4'b0000;
                outputCRC_1 = 1'b0;
              end
            end
          end
          else begin
            if (CRCControlFSM_Cnt1 == 5'b01011) begin
              validOutTemp = 1'b1;
            end
            else if ((CRCControlFSM_Cnt2 == 4'b1010) || CRCControlFSM_Cnt3_enb) begin
              validOutTemp = 1'b1;
            end
            else begin
              CRCControlFSM_Cnt1_next = CRCControlFSM_Cnt1 + 5'b00001;
              validOutTemp = 1'b0;
            end
            if (CRCControlFSM_Cnt3_enb) begin
              outputCRC_1 = 1'b1;
              if (CRCControlFSM_Cnt3 == 4'b1010) begin
                CRCControlFSM_Cnt3_enb_next = 1'b0;
                CRCControlFSM_Cnt3_temp = 4'b0000;
              end
              CRCControlFSM_Cnt3_temp = CRCControlFSM_Cnt3_temp + 4'b0001;
            end
            else begin
              outputCRC_1 = 1'b0;
            end
            if (CRCControlFSM_Cnt2 == 4'b1010) begin
              CRCControlFSM_FSMNextState_next = 2'b00;
              endOutTemp = 1'b1;
              CRCControlFSM_Cnt3_enb_next = 1'b1;
              CRCControlFSM_Cnt3_temp = 4'b0000;
              CRCControlFSM_Cnt2_next = 4'b0000;
            end
            else begin
              CRCControlFSM_FSMNextState_next = 2'b10;
              endOutTemp = 1'b0;
              CRCControlFSM_Cnt2_next = CRCControlFSM_Cnt2 + 4'b0001;
            end
          end
        end
      default :
        begin
          CRCControlFSM_FSMNextState_next = 2'b00;
          validOutTemp = 1'b0;
          endOutTemp = 1'b0;
          outputCRC_1 = 1'b0;
          processMsg_1 = 1'b0;
          padZero_1 = 1'b0;
          regClr_1 = 1'b0;
          validLowFlag = 1'b1;
        end
    endcase
    counter_1 = CRCControlFSM_Cnt2;
    counter_outputCRC_1 = CRCControlFSM_Cnt3;
    CRCControlFSM_Cnt3_next = CRCControlFSM_Cnt3_temp;
  end



  // buffer for endOut
  always @(posedge clk or posedge reset)
    begin : dataOut_register_1_process
      if (reset == 1'b1) begin
        dataOut_register_reg_1[0] <= 1'b0;
        dataOut_register_reg_1[1] <= 1'b0;
        dataOut_register_reg_1[2] <= 1'b0;
        dataOut_register_reg_1[3] <= 1'b0;
        dataOut_register_reg_1[4] <= 1'b0;
        dataOut_register_reg_1[5] <= 1'b0;
        dataOut_register_reg_1[6] <= 1'b0;
        dataOut_register_reg_1[7] <= 1'b0;
        dataOut_register_reg_1[8] <= 1'b0;
        dataOut_register_reg_1[9] <= 1'b0;
        dataOut_register_reg_1[10] <= 1'b0;
      end
      else begin
        if (enb) begin
          dataOut_register_reg_1[0] <= dataOut_register_reg_next_1[0];
          dataOut_register_reg_1[1] <= dataOut_register_reg_next_1[1];
          dataOut_register_reg_1[2] <= dataOut_register_reg_next_1[2];
          dataOut_register_reg_1[3] <= dataOut_register_reg_next_1[3];
          dataOut_register_reg_1[4] <= dataOut_register_reg_next_1[4];
          dataOut_register_reg_1[5] <= dataOut_register_reg_next_1[5];
          dataOut_register_reg_1[6] <= dataOut_register_reg_next_1[6];
          dataOut_register_reg_1[7] <= dataOut_register_reg_next_1[7];
          dataOut_register_reg_1[8] <= dataOut_register_reg_next_1[8];
          dataOut_register_reg_1[9] <= dataOut_register_reg_next_1[9];
          dataOut_register_reg_1[10] <= dataOut_register_reg_next_1[10];
        end
      end
    end

  assign endOut = dataOut_register_reg_1[10];
  assign dataOut_register_reg_next_1[0] = endOutTemp;
  assign dataOut_register_reg_next_1[1] = dataOut_register_reg_1[0];
  assign dataOut_register_reg_next_1[2] = dataOut_register_reg_1[1];
  assign dataOut_register_reg_next_1[3] = dataOut_register_reg_1[2];
  assign dataOut_register_reg_next_1[4] = dataOut_register_reg_1[3];
  assign dataOut_register_reg_next_1[5] = dataOut_register_reg_1[4];
  assign dataOut_register_reg_next_1[6] = dataOut_register_reg_1[5];
  assign dataOut_register_reg_next_1[7] = dataOut_register_reg_1[6];
  assign dataOut_register_reg_next_1[8] = dataOut_register_reg_1[7];
  assign dataOut_register_reg_next_1[9] = dataOut_register_reg_1[8];
  assign dataOut_register_reg_next_1[10] = dataOut_register_reg_1[9];



  // buffer for validLowFlag
  always @(posedge clk or posedge reset)
    begin : validLowFlag_register_process
      if (reset == 1'b1) begin
        validLowFlag_register_reg[0] <= 1'b0;
        validLowFlag_register_reg[1] <= 1'b0;
        validLowFlag_register_reg[2] <= 1'b0;
        validLowFlag_register_reg[3] <= 1'b0;
        validLowFlag_register_reg[4] <= 1'b0;
        validLowFlag_register_reg[5] <= 1'b0;
        validLowFlag_register_reg[6] <= 1'b0;
        validLowFlag_register_reg[7] <= 1'b0;
        validLowFlag_register_reg[8] <= 1'b0;
        validLowFlag_register_reg[9] <= 1'b0;
        validLowFlag_register_reg[10] <= 1'b0;
      end
      else begin
        if (enb) begin
          validLowFlag_register_reg[0] <= validLowFlag_register_reg_next[0];
          validLowFlag_register_reg[1] <= validLowFlag_register_reg_next[1];
          validLowFlag_register_reg[2] <= validLowFlag_register_reg_next[2];
          validLowFlag_register_reg[3] <= validLowFlag_register_reg_next[3];
          validLowFlag_register_reg[4] <= validLowFlag_register_reg_next[4];
          validLowFlag_register_reg[5] <= validLowFlag_register_reg_next[5];
          validLowFlag_register_reg[6] <= validLowFlag_register_reg_next[6];
          validLowFlag_register_reg[7] <= validLowFlag_register_reg_next[7];
          validLowFlag_register_reg[8] <= validLowFlag_register_reg_next[8];
          validLowFlag_register_reg[9] <= validLowFlag_register_reg_next[9];
          validLowFlag_register_reg[10] <= validLowFlag_register_reg_next[10];
        end
      end
    end

  assign validLowFlagDelay = validLowFlag_register_reg[10];
  assign validLowFlag_register_reg_next[0] = validLowFlag;
  assign validLowFlag_register_reg_next[1] = validLowFlag_register_reg[0];
  assign validLowFlag_register_reg_next[2] = validLowFlag_register_reg[1];
  assign validLowFlag_register_reg_next[3] = validLowFlag_register_reg[2];
  assign validLowFlag_register_reg_next[4] = validLowFlag_register_reg[3];
  assign validLowFlag_register_reg_next[5] = validLowFlag_register_reg[4];
  assign validLowFlag_register_reg_next[6] = validLowFlag_register_reg[5];
  assign validLowFlag_register_reg_next[7] = validLowFlag_register_reg[6];
  assign validLowFlag_register_reg_next[8] = validLowFlag_register_reg[7];
  assign validLowFlag_register_reg_next[9] = validLowFlag_register_reg[8];
  assign validLowFlag_register_reg_next[10] = validLowFlag_register_reg[9];



  // drag validOut down when validIn is low in the message processing state
  assign validOut = validOutTemp & validLowFlagDelay;



  assign processMsg = processMsg_1;

  assign padZero = padZero_1;

  assign outputCRC = outputCRC_1;

  assign regClr = regClr_1;

  assign counter = counter_1;

  assign counter_outputCRC = counter_outputCRC_1;

endmodule  // CRCGenControl

