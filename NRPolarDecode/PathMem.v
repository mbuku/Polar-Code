// -------------------------------------------------------------
// 
// File Name: hdlsrc\NRPolarDecodeHDL\PathMem.v
// Created: 2022-01-15 05:13:24
// 
// Generated by MATLAB 9.8 and HDL Coder 3.16
// 
// -------------------------------------------------------------


// -------------------------------------------------------------
// 
// Module: PathMem
// Source Path: NRPolarDecodeHDL/HDL Algorithm/NR Polar Decoder/PathMem
// Hierarchy Level: 2
// 
// -------------------------------------------------------------

`timescale 1 ns / 1 ns

module PathMem
          (clk,
           reset,
           enb,
           hardDecs_0,
           hardDecs_1,
           pathWrEn,
           contPaths_0,
           contPaths_1,
           pathRdAddr,
           rdPath,
           rstRdCnt,
           rstWrCnt,
           canPaths_0,
           canPaths_1,
           copyEn);


  input   clk;
  input   reset;
  input   enb;
  input   hardDecs_0;  // ufix1
  input   hardDecs_1;  // ufix1
  input   pathWrEn;
  input   contPaths_0;  // ufix1
  input   contPaths_1;  // ufix1
  input   [9:0] pathRdAddr;  // ufix10
  input   rdPath;
  input   rstRdCnt;
  input   rstWrCnt;
  output  canPaths_0;  // ufix1
  output  canPaths_1;  // ufix1
  output  copyEn;


  reg  rstWrCnt_reg;
  reg [9:0] pathWrAddr;  // ufix10
  wire dupUpToL;
  wire [0:1] contPaths;  // ufix1 [2]
  reg  [0:1] contPaths_reg;  // ufix1 [2]
  wire [0:1] pathOW;  // boolean [2]
  wire pathOW_0;
  wire pathOW_1;
  wire anyOW;
  wire virtPtrWrEn;
  reg  virtPtrWrEn_reg;
  reg [4:0] virtPtrWrAddr;  // ufix5
  wire pathOW_0_1;
  wire [10:0] virtPtrDin;  // ufix11
  reg [10:0] virtPtrDin_reg;  // ufix11
  reg [9:0] pathRdAddr_reg;  // ufix10
  reg  rdPath_reg;
  reg [4:0] prevCnt;  // ufix5
  wire [4:0] newCnt;  // ufix5
  wire [4:0] curCnt;  // ufix5
  reg  pastPtrsEnd_reg;
  wire notPastPtrsEnd;
  wire [10:0] virtPtrDout;  // ufix11
  wire [9:0] nextVirtPtrAddr;  // ufix10
  wire relop_relop1;
  wire incPathPtrRdAddr;
  wire relop_relop1_1;
  wire pathPtr;  // ufix1
  wire pathConst_0;  // ufix1
  wire pathPtr_reg_0;  // ufix1
  reg  physAddr_reg_0;  // ufix1
  wire [0:1] hardDecsFlip;  // ufix1 [2]
  wire [1:0] hardDecsCat;  // ufix2
  reg [1:0] hardDecsCat_reg;  // ufix2
  reg [9:0] pathWrAddr_reg;  // ufix10
  reg  pathWrEn_reg;
  wire [1:0] pathDout;  // ufix2
  wire hardDecsDecat_0;  // ufix1
  reg  hardDecsDecat_reg_0;  // ufix1
  wire hardDecsDecat_1;  // ufix1
  reg  hardDecsDecat_reg_1;  // ufix1
  wire reconPaths_0;  // ufix1
  wire pathConst_1;  // ufix1
  wire pathPtr_reg_1;  // ufix1
  reg  physAddr_reg_1;  // ufix1
  wire reconPaths_1;  // ufix1


  always @(posedge clk or posedge reset)
    begin : reg_rsvd_process
      if (reset == 1'b1) begin
        rstWrCnt_reg <= 1'b0;
      end
      else begin
        if (enb) begin
          rstWrCnt_reg <= rstWrCnt;
        end
      end
    end



  // Free running, Unsigned Counter
  //  initial value   = 0
  //  step value      = 1
  always @(posedge clk or posedge reset)
    begin : counter_process
      if (reset == 1'b1) begin
        pathWrAddr <= 10'b0000000000;
      end
      else begin
        if (enb) begin
          if (rstWrCnt == 1'b1) begin
            pathWrAddr <= 10'b0000000000;
          end
          else if (pathWrEn == 1'b1) begin
            pathWrAddr <= pathWrAddr + 10'b0000000001;
          end
        end
      end
    end



  assign dupUpToL = pathWrAddr >= 10'b0000000001;



  assign contPaths[0] = contPaths_0;
  assign contPaths[1] = contPaths_1;

  always @(posedge clk or posedge reset)
    begin : reg_rsvd_1_process
      if (reset == 1'b1) begin
        contPaths_reg[0] <= 1'b0;
        contPaths_reg[1] <= 1'b0;
      end
      else begin
        if (enb) begin
          contPaths_reg[0] <= contPaths[0];
          contPaths_reg[1] <= contPaths[1];
        end
      end
    end



  assign pathOW[0] = contPaths_reg[0] != 1'b0;
  assign pathOW[1] = contPaths_reg[1] != 1'b1;



  assign pathOW_0 = pathOW[0];

  assign pathOW_1 = pathOW[1];

  assign anyOW = pathOW_0 | pathOW_1;



  assign virtPtrWrEn = anyOW & (pathWrEn & dupUpToL);



  always @(posedge clk or posedge reset)
    begin : reg_rsvd_2_process
      if (reset == 1'b1) begin
        virtPtrWrEn_reg <= 1'b0;
      end
      else begin
        if (enb) begin
          virtPtrWrEn_reg <= virtPtrWrEn;
        end
      end
    end



  // Free running, Unsigned Counter
  //  initial value   = 0
  //  step value      = 1
  always @(posedge clk or posedge reset)
    begin : counter_1_process
      if (reset == 1'b1) begin
        virtPtrWrAddr <= 5'b00000;
      end
      else begin
        if (enb) begin
          if (rstWrCnt_reg == 1'b1) begin
            virtPtrWrAddr <= 5'b00000;
          end
          else if (virtPtrWrEn_reg == 1'b1) begin
            virtPtrWrAddr <= virtPtrWrAddr + 5'b00001;
          end
        end
      end
    end



  assign pathOW_0_1 = pathOW[0];

  assign virtPtrDin = {pathWrAddr, pathOW_0_1};



  always @(posedge clk or posedge reset)
    begin : reg_rsvd_3_process
      if (reset == 1'b1) begin
        virtPtrDin_reg <= 11'b00000000000;
      end
      else begin
        if (enb) begin
          virtPtrDin_reg <= virtPtrDin;
        end
      end
    end



  always @(posedge clk or posedge reset)
    begin : reg_rsvd_4_process
      if (reset == 1'b1) begin
        pathRdAddr_reg <= 10'b0000000000;
      end
      else begin
        if (enb) begin
          pathRdAddr_reg <= pathRdAddr;
        end
      end
    end



  always @(posedge clk or posedge reset)
    begin : reg_rsvd_5_process
      if (reset == 1'b1) begin
        rdPath_reg <= 1'b0;
      end
      else begin
        if (enb) begin
          rdPath_reg <= rdPath;
        end
      end
    end



  assign newCnt = prevCnt + 5'b00001;



  always @(posedge clk or posedge reset)
    begin : reg_rsvd_6_process
      if (reset == 1'b1) begin
        prevCnt <= 5'b00000;
      end
      else begin
        if (enb) begin
          if (rstRdCnt == 1'b1) begin
            prevCnt <= 5'b00000;
          end
          else begin
            prevCnt <= curCnt;
          end
        end
      end
    end



  assign notPastPtrsEnd =  ~ pastPtrsEnd_reg;



  SimpleDualPortRAM_generic #(.AddrWidth(5),
                              .DataWidth(11)
                              )
                            u_simpleDualPortRam (.clk(clk),
                                                 .enb(enb),
                                                 .wr_din(virtPtrDin_reg),
                                                 .wr_addr(virtPtrWrAddr),
                                                 .wr_en(virtPtrWrEn_reg),
                                                 .rd_addr(curCnt),
                                                 .rd_dout(virtPtrDout)
                                                 );

  assign nextVirtPtrAddr = virtPtrDout[10:1];



  assign relop_relop1 = nextVirtPtrAddr == pathRdAddr_reg;



  assign incPathPtrRdAddr = notPastPtrsEnd & (relop_relop1 & rdPath_reg);



  assign curCnt = (incPathPtrRdAddr == 1'b0 ? prevCnt :
              newCnt);



  assign relop_relop1_1 = virtPtrWrAddr == curCnt;



  always @(posedge clk or posedge reset)
    begin : reg_rsvd_7_process
      if (reset == 1'b1) begin
        pastPtrsEnd_reg <= 1'b0;
      end
      else begin
        if (enb) begin
          pastPtrsEnd_reg <= relop_relop1_1;
        end
      end
    end



  assign pathPtr = virtPtrDout[0];



  assign pathConst_0 = 1'b0;



  assign pathPtr_reg_0 = (pastPtrsEnd_reg == 1'b0 ? pathPtr :
              pathConst_0);



  always @(posedge clk or posedge reset)
    begin : reg_rsvd_8_process
      if (reset == 1'b1) begin
        physAddr_reg_0 <= 1'b0;
      end
      else begin
        if (enb) begin
          physAddr_reg_0 <= pathPtr_reg_0;
        end
      end
    end



  assign hardDecsFlip[0] = hardDecs_1;
  assign hardDecsFlip[1] = hardDecs_0;

  assign hardDecsCat = {hardDecsFlip[0], hardDecsFlip[1]};



  always @(posedge clk or posedge reset)
    begin : reg_rsvd_9_process
      if (reset == 1'b1) begin
        hardDecsCat_reg <= 2'b00;
      end
      else begin
        if (enb) begin
          hardDecsCat_reg <= hardDecsCat;
        end
      end
    end



  always @(posedge clk or posedge reset)
    begin : reg_rsvd_10_process
      if (reset == 1'b1) begin
        pathWrAddr_reg <= 10'b0000000000;
      end
      else begin
        if (enb) begin
          pathWrAddr_reg <= pathWrAddr;
        end
      end
    end



  always @(posedge clk or posedge reset)
    begin : reg_rsvd_11_process
      if (reset == 1'b1) begin
        pathWrEn_reg <= 1'b0;
      end
      else begin
        if (enb) begin
          pathWrEn_reg <= pathWrEn;
        end
      end
    end



  SimpleDualPortRAM_generic #(.AddrWidth(10),
                              .DataWidth(2)
                              )
                            u_simpleDualPortRam_1 (.clk(clk),
                                                   .enb(enb),
                                                   .wr_din(hardDecsCat_reg),
                                                   .wr_addr(pathWrAddr_reg),
                                                   .wr_en(pathWrEn_reg),
                                                   .rd_addr(pathRdAddr_reg),
                                                   .rd_dout(pathDout)
                                                   );

  assign hardDecsDecat_0 = pathDout[0];



  always @(posedge clk or posedge reset)
    begin : reg_rsvd_12_process
      if (reset == 1'b1) begin
        hardDecsDecat_reg_0 <= 1'b0;
      end
      else begin
        if (enb) begin
          hardDecsDecat_reg_0 <= hardDecsDecat_0;
        end
      end
    end



  assign hardDecsDecat_1 = pathDout[1];



  always @(posedge clk or posedge reset)
    begin : reg_rsvd_13_process
      if (reset == 1'b1) begin
        hardDecsDecat_reg_1 <= 1'b0;
      end
      else begin
        if (enb) begin
          hardDecsDecat_reg_1 <= hardDecsDecat_1;
        end
      end
    end



  assign reconPaths_0 = (physAddr_reg_0 == 1'b0 ? hardDecsDecat_reg_0 :
              hardDecsDecat_reg_1);



  assign canPaths_0 = reconPaths_0;

  assign pathConst_1 = 1'b1;



  assign pathPtr_reg_1 = (pastPtrsEnd_reg == 1'b0 ? pathPtr :
              pathConst_1);



  always @(posedge clk or posedge reset)
    begin : reg_rsvd_14_process
      if (reset == 1'b1) begin
        physAddr_reg_1 <= 1'b0;
      end
      else begin
        if (enb) begin
          physAddr_reg_1 <= pathPtr_reg_1;
        end
      end
    end



  assign reconPaths_1 = (physAddr_reg_1 == 1'b0 ? hardDecsDecat_reg_0 :
              hardDecsDecat_reg_1);



  assign canPaths_1 = reconPaths_1;

  assign copyEn = virtPtrWrAddr != 5'b11111;



endmodule  // PathMem

