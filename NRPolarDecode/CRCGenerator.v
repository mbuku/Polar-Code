// -------------------------------------------------------------
// 
// File Name: hdlsrc\NRPolarDecodeHDL\CRCGenerator.v
// Created: 2022-01-15 05:13:24
// 
// Generated by MATLAB 9.8 and HDL Coder 3.16
// 
// -------------------------------------------------------------


// -------------------------------------------------------------
// 
// Module: CRCGenerator
// Source Path: NRPolarDecodeHDL/HDL Algorithm/NR Polar Decoder/CRC Decoder/CRCGenerator
// Hierarchy Level: 3
// 
// -------------------------------------------------------------

`timescale 1 ns / 1 ns

module CRCGenerator
          (clk,
           reset,
           enb,
           dataIn,
           startIn,
           endIn,
           validIn,
           dataOut,
           startOut,
           endOut,
           validOut);


  input   clk;
  input   reset;
  input   enb;
  input   dataIn;
  input   startIn;  // ufix1
  input   endIn;  // ufix1
  input   validIn;  // ufix1
  output  dataOut;
  output  startOut;  // ufix1
  output  endOut;  // ufix1
  output  validOut;  // ufix1


  wire tstartout;  // ufix1
  wire processMsg;  // ufix1
  wire padZero;  // ufix1
  wire outputCRC;  // ufix1
  wire lastfout;  // ufix1
  wire validdata;  // ufix1
  wire regClr;  // ufix1
  wire [3:0] counter;  // ufix4
  wire [3:0] counter_opcrc;  // ufix4
  wire const0;  // ufix1
  wire msgenb;  // ufix1
  reg  datainReg;
  reg  [0:10] alpha_reg;  // ufix1 [11]
  wire [0:10] alpha_reg_next;  // ufix1 [11]
  wire dataBuffer;  // ufix1
  wire crcCheckSum_0;  // ufix1
  wire crcCheckSum_1;  // ufix1
  wire crcCheckSum_2;  // ufix1
  wire crcCheckSum_3;  // ufix1
  wire crcCheckSum_4;  // ufix1
  wire crcCheckSum_5;  // ufix1
  wire crcCheckSum_6;  // ufix1
  wire crcCheckSum_7;  // ufix1
  wire crcCheckSum_8;  // ufix1
  wire crcCheckSum_9;  // ufix1
  wire crcCheckSum_10;  // ufix1
  wire crcOut;  // ufix1
  wire msgcrc;  // ufix1
  wire tdataout;  // ufix1
  reg  dataOut_1;
  wire tstartoutGated;  // ufix1
  reg  startOut_1;  // ufix1
  reg  endOut_1;  // ufix1
  reg  validOut_1;  // ufix1


  CRCGenControl u_Controlsignal_inst (.clk(clk),
                                      .reset(reset),
                                      .enb(enb),
                                      .startIn(startIn),  // ufix1
                                      .endIn(endIn),  // ufix1
                                      .validIn(validIn),  // ufix1
                                      .startOut(tstartout),  // ufix1
                                      .processMsg(processMsg),  // ufix1
                                      .padZero(padZero),  // ufix1
                                      .outputCRC(outputCRC),  // ufix1
                                      .endOut(lastfout),  // ufix1
                                      .validOut(validdata),  // ufix1
                                      .regClr(regClr),  // ufix1
                                      .counter(counter),  // ufix4
                                      .counter_outputCRC(counter_opcrc)  // ufix4
                                      );

  // Constant Zero
  assign const0 = 1'b0;



  assign msgenb = processMsg | padZero;



  always @(posedge clk or posedge reset)
    begin : datainput_register_process
      if (reset == 1'b1) begin
        datainReg <= 1'b0;
      end
      else begin
        if (enb) begin
          datainReg <= dataIn;
        end
      end
    end



  // Buffer Input Data
  always @(posedge clk or posedge reset)
    begin : c_process
      if (reset == 1'b1) begin
        alpha_reg[0] <= 1'b0;
        alpha_reg[1] <= 1'b0;
        alpha_reg[2] <= 1'b0;
        alpha_reg[3] <= 1'b0;
        alpha_reg[4] <= 1'b0;
        alpha_reg[5] <= 1'b0;
        alpha_reg[6] <= 1'b0;
        alpha_reg[7] <= 1'b0;
        alpha_reg[8] <= 1'b0;
        alpha_reg[9] <= 1'b0;
        alpha_reg[10] <= 1'b0;
      end
      else begin
        if (enb && enb && msgenb) begin
          alpha_reg[0] <= alpha_reg_next[0];
          alpha_reg[1] <= alpha_reg_next[1];
          alpha_reg[2] <= alpha_reg_next[2];
          alpha_reg[3] <= alpha_reg_next[3];
          alpha_reg[4] <= alpha_reg_next[4];
          alpha_reg[5] <= alpha_reg_next[5];
          alpha_reg[6] <= alpha_reg_next[6];
          alpha_reg[7] <= alpha_reg_next[7];
          alpha_reg[8] <= alpha_reg_next[8];
          alpha_reg[9] <= alpha_reg_next[9];
          alpha_reg[10] <= alpha_reg_next[10];
        end
      end
    end

  assign dataBuffer = alpha_reg[10];
  assign alpha_reg_next[0] = datainReg;
  assign alpha_reg_next[1] = alpha_reg[0];
  assign alpha_reg_next[2] = alpha_reg[1];
  assign alpha_reg_next[3] = alpha_reg[2];
  assign alpha_reg_next[4] = alpha_reg[3];
  assign alpha_reg_next[5] = alpha_reg[4];
  assign alpha_reg_next[6] = alpha_reg[5];
  assign alpha_reg_next[7] = alpha_reg[6];
  assign alpha_reg_next[8] = alpha_reg[7];
  assign alpha_reg_next[9] = alpha_reg[8];
  assign alpha_reg_next[10] = alpha_reg[9];



  // Select CRC output bits
  // 
  // Select CRC output bits
  // 
  // Select CRC output bits
  // 
  // Select CRC output bits
  // 
  // Select CRC output bits
  // 
  // Select CRC output bits
  // 
  // Select CRC output bits
  // 
  // Select CRC output bits
  // 
  // Select CRC output bits
  // 
  // Select CRC output bits
  // 
  // Select CRC output bits
  CRCGenCompute u_ComputeCRC_inst (.clk(clk),
                                   .reset(reset),
                                   .enb(enb),
                                   .datainReg(datainReg),
                                   .validIn(validIn),  // ufix1
                                   .processMsg(processMsg),  // ufix1
                                   .padZero(padZero),  // ufix1
                                   .counter(counter),  // ufix4
                                   .regClr(regClr),  // ufix1
                                   .crcChecksum_0(crcCheckSum_0),  // ufix1
                                   .crcChecksum_1(crcCheckSum_1),  // ufix1
                                   .crcChecksum_2(crcCheckSum_2),  // ufix1
                                   .crcChecksum_3(crcCheckSum_3),  // ufix1
                                   .crcChecksum_4(crcCheckSum_4),  // ufix1
                                   .crcChecksum_5(crcCheckSum_5),  // ufix1
                                   .crcChecksum_6(crcCheckSum_6),  // ufix1
                                   .crcChecksum_7(crcCheckSum_7),  // ufix1
                                   .crcChecksum_8(crcCheckSum_8),  // ufix1
                                   .crcChecksum_9(crcCheckSum_9),  // ufix1
                                   .crcChecksum_10(crcCheckSum_10)  // ufix1
                                   );

  assign crcOut = (counter_opcrc == 4'b0000 ? crcCheckSum_0 :
              (counter_opcrc == 4'b0001 ? crcCheckSum_1 :
              (counter_opcrc == 4'b0010 ? crcCheckSum_2 :
              (counter_opcrc == 4'b0011 ? crcCheckSum_3 :
              (counter_opcrc == 4'b0100 ? crcCheckSum_4 :
              (counter_opcrc == 4'b0101 ? crcCheckSum_5 :
              (counter_opcrc == 4'b0110 ? crcCheckSum_6 :
              (counter_opcrc == 4'b0111 ? crcCheckSum_7 :
              (counter_opcrc == 4'b1000 ? crcCheckSum_8 :
              (counter_opcrc == 4'b1001 ? crcCheckSum_9 :
              crcCheckSum_10))))))))));



  assign msgcrc = (outputCRC == 1'b0 ? dataBuffer :
              crcOut);



  // Output data and CRC CheckSum
  assign tdataout = (validdata == 1'b0 ? const0 :
              msgcrc);



  // Data output register
  always @(posedge clk or posedge reset)
    begin : dataOut_register_process
      if (reset == 1'b1) begin
        dataOut_1 <= 1'b0;
      end
      else begin
        if (enb) begin
          dataOut_1 <= tdataout;
        end
      end
    end



  assign tstartoutGated = tstartout & validdata;



  // startOut output register
  always @(posedge clk or posedge reset)
    begin : startOut_register_process
      if (reset == 1'b1) begin
        startOut_1 <= 1'b0;
      end
      else begin
        if (enb) begin
          startOut_1 <= tstartoutGated;
        end
      end
    end



  // endOut output register
  always @(posedge clk or posedge reset)
    begin : endout_register_process
      if (reset == 1'b1) begin
        endOut_1 <= 1'b0;
      end
      else begin
        if (enb) begin
          endOut_1 <= lastfout;
        end
      end
    end



  // validOut output register
  always @(posedge clk or posedge reset)
    begin : validout_register_process
      if (reset == 1'b1) begin
        validOut_1 <= 1'b0;
      end
      else begin
        if (enb) begin
          validOut_1 <= validdata;
        end
      end
    end



  assign dataOut = dataOut_1;

  assign startOut = startOut_1;

  assign endOut = endOut_1;

  assign validOut = validOut_1;

endmodule  // CRCGenerator

