// -------------------------------------------------------------
// 
// File Name: hdlsrc\NRPolarEncodeHDL\configure.v
// Created: 2022-01-15 05:10:41
// 
// Generated by MATLAB 9.8 and HDL Coder 3.16
// 
// -------------------------------------------------------------


// -------------------------------------------------------------
// 
// Module: configure
// Source Path: NRPolarEncodeHDL/HDL Algorithm/NR Polar Encoder/configure
// Hierarchy Level: 2
// 
// -------------------------------------------------------------

`timescale 1 ns / 1 ns

module configure
          (clk,
           reset,
           enb,
           K,
           E,
           QAddr,
           reconfig,
           n,
           Q,
           intlvDout,
           intlvAddr,
           intlvValid,
           configured,
           NSub1,
           configValid);


  input   clk;
  input   reset;
  input   enb;
  input   [9:0] K;  // ufix10
  input   [16:0] E;  // ufix17
  input   [9:0] QAddr;  // ufix10
  input   reconfig;
  output  [7:0] n;  // uint8
  output  Q;
  output  intlvDout;  // ufix1
  output  intlvAddr;  // ufix1
  output  intlvValid;  // ufix1
  output  configured;
  output  [9:0] NSub1;  // ufix10
  output  configValid;


  wire [9:0] order_out1;  // ufix10
  wire [10:0] order_out2;  // ufix11
  wire [7:0] order_out3;  // uint8
  reg  [0:7] Delay_reg;  // ufix1 [8]
  wire [0:7] Delay_reg_next;  // ufix1 [8]
  wire Delay_out1;
  reg [16:0] Delay6_out1;  // ufix17
  wire [16:0] Less_Than_1_1;  // ufix17
  wire Less_Than_relop1;
  reg  Delay5_out1;
  wire configured_1;
  wire [9:0] idx;  // ufix10
  wire enItlvMap;
  wire enSequence;
  wire rstSequence;
  wire enSP;
  reg [9:0] Delay2_reg [0:4];  // ufix10 [5]
  wire [9:0] Delay2_reg_next [0:4];  // ufix10 [5]
  wire [9:0] Delay2_out1;  // ufix10
  reg  [0:4] Delay3_reg;  // ufix1 [5]
  wire [0:4] Delay3_reg_next;  // ufix1 [5]
  wire Delay3_out1;
  reg  [0:4] Delay7_reg;  // ufix1 [5]
  wire [0:4] Delay7_reg_next;  // ufix1 [5]
  wire Delay7_out1;
  wire [9:0] Cast_out1;  // ufix10
  wire shortPunc_out1;
  wire shortPunc_out2;  // ufix1
  wire [9:0] shortPunc_out3;  // ufix10
  wire sequence_out1;
  wire itlvMap_out1;  // ufix1
  wire itlvMap_out2;  // ufix1
  wire itlvMap_out3;  // ufix1
  reg  [0:10] Delay1_reg;  // ufix1 [11]
  wire [0:10] Delay1_reg_next;  // ufix1 [11]
  wire Delay1_out1;
  wire validateConfig_out1;

  // E < N


  order u_order (.clk(clk),
                 .reset(reset),
                 .enb(enb),
                 .E(E),  // ufix17
                 .K(K),  // ufix10
                 .N_1(order_out1),  // ufix10
                 .N(order_out2),  // ufix11
                 .n_2(order_out3)  // uint8
                 );

  assign n = order_out3;

  always @(posedge clk or posedge reset)
    begin : Delay_process
      if (reset == 1'b1) begin
        Delay_reg[0] <= 1'b0;
        Delay_reg[1] <= 1'b0;
        Delay_reg[2] <= 1'b0;
        Delay_reg[3] <= 1'b0;
        Delay_reg[4] <= 1'b0;
        Delay_reg[5] <= 1'b0;
        Delay_reg[6] <= 1'b0;
        Delay_reg[7] <= 1'b0;
      end
      else begin
        if (enb) begin
          Delay_reg[0] <= Delay_reg_next[0];
          Delay_reg[1] <= Delay_reg_next[1];
          Delay_reg[2] <= Delay_reg_next[2];
          Delay_reg[3] <= Delay_reg_next[3];
          Delay_reg[4] <= Delay_reg_next[4];
          Delay_reg[5] <= Delay_reg_next[5];
          Delay_reg[6] <= Delay_reg_next[6];
          Delay_reg[7] <= Delay_reg_next[7];
        end
      end
    end

  assign Delay_out1 = Delay_reg[7];
  assign Delay_reg_next[0] = reconfig;
  assign Delay_reg_next[1] = Delay_reg[0];
  assign Delay_reg_next[2] = Delay_reg[1];
  assign Delay_reg_next[3] = Delay_reg[2];
  assign Delay_reg_next[4] = Delay_reg[3];
  assign Delay_reg_next[5] = Delay_reg[4];
  assign Delay_reg_next[6] = Delay_reg[5];
  assign Delay_reg_next[7] = Delay_reg[6];



  always @(posedge clk or posedge reset)
    begin : Delay6_process
      if (reset == 1'b1) begin
        Delay6_out1 <= 17'b00000000000000000;
      end
      else begin
        if (enb) begin
          Delay6_out1 <= E;
        end
      end
    end



  assign Less_Than_1_1 = {6'b0, order_out2};
  assign Less_Than_relop1 = Delay6_out1 < Less_Than_1_1;



  always @(posedge clk or posedge reset)
    begin : Delay5_process
      if (reset == 1'b1) begin
        Delay5_out1 <= 1'b0;
      end
      else begin
        if (enb) begin
          Delay5_out1 <= Less_Than_relop1;
        end
      end
    end



  configControl u_configControl (.clk(clk),
                                 .reset(reset),
                                 .enb(enb),
                                 .start(Delay_out1),
                                 .rateLT(Delay5_out1),
                                 .N(order_out1),  // ufix10
                                 .configured(configured_1),
                                 .idx(idx),  // ufix10
                                 .enItlvMap(enItlvMap),
                                 .enSequence(enSequence),
                                 .rstSequence(rstSequence),
                                 .enSP(enSP)
                                 );

  always @(posedge clk or posedge reset)
    begin : Delay2_process
      if (reset == 1'b1) begin
        Delay2_reg[0] <= 10'b0000000000;
        Delay2_reg[1] <= 10'b0000000000;
        Delay2_reg[2] <= 10'b0000000000;
        Delay2_reg[3] <= 10'b0000000000;
        Delay2_reg[4] <= 10'b0000000000;
      end
      else begin
        if (enb) begin
          Delay2_reg[0] <= Delay2_reg_next[0];
          Delay2_reg[1] <= Delay2_reg_next[1];
          Delay2_reg[2] <= Delay2_reg_next[2];
          Delay2_reg[3] <= Delay2_reg_next[3];
          Delay2_reg[4] <= Delay2_reg_next[4];
        end
      end
    end

  assign Delay2_out1 = Delay2_reg[4];
  assign Delay2_reg_next[0] = idx;
  assign Delay2_reg_next[1] = Delay2_reg[0];
  assign Delay2_reg_next[2] = Delay2_reg[1];
  assign Delay2_reg_next[3] = Delay2_reg[2];
  assign Delay2_reg_next[4] = Delay2_reg[3];



  always @(posedge clk or posedge reset)
    begin : Delay3_process
      if (reset == 1'b1) begin
        Delay3_reg[0] <= 1'b0;
        Delay3_reg[1] <= 1'b0;
        Delay3_reg[2] <= 1'b0;
        Delay3_reg[3] <= 1'b0;
        Delay3_reg[4] <= 1'b0;
      end
      else begin
        if (enb) begin
          Delay3_reg[0] <= Delay3_reg_next[0];
          Delay3_reg[1] <= Delay3_reg_next[1];
          Delay3_reg[2] <= Delay3_reg_next[2];
          Delay3_reg[3] <= Delay3_reg_next[3];
          Delay3_reg[4] <= Delay3_reg_next[4];
        end
      end
    end

  assign Delay3_out1 = Delay3_reg[4];
  assign Delay3_reg_next[0] = enSequence;
  assign Delay3_reg_next[1] = Delay3_reg[0];
  assign Delay3_reg_next[2] = Delay3_reg[1];
  assign Delay3_reg_next[3] = Delay3_reg[2];
  assign Delay3_reg_next[4] = Delay3_reg[3];



  always @(posedge clk or posedge reset)
    begin : Delay7_process
      if (reset == 1'b1) begin
        Delay7_reg[0] <= 1'b0;
        Delay7_reg[1] <= 1'b0;
        Delay7_reg[2] <= 1'b0;
        Delay7_reg[3] <= 1'b0;
        Delay7_reg[4] <= 1'b0;
      end
      else begin
        if (enb) begin
          Delay7_reg[0] <= Delay7_reg_next[0];
          Delay7_reg[1] <= Delay7_reg_next[1];
          Delay7_reg[2] <= Delay7_reg_next[2];
          Delay7_reg[3] <= Delay7_reg_next[3];
          Delay7_reg[4] <= Delay7_reg_next[4];
        end
      end
    end

  assign Delay7_out1 = Delay7_reg[4];
  assign Delay7_reg_next[0] = rstSequence;
  assign Delay7_reg_next[1] = Delay7_reg[0];
  assign Delay7_reg_next[2] = Delay7_reg[1];
  assign Delay7_reg_next[3] = Delay7_reg[2];
  assign Delay7_reg_next[4] = Delay7_reg[3];



  assign Cast_out1 = E[9:0];



  shortPunc u_shortPunc (.clk(clk),
                         .reset(reset),
                         .enb(enb),
                         .idx(idx),  // ufix10
                         .enShortPunc(enSP),
                         .K(K),  // ufix10
                         .N(order_out2),  // ufix11
                         .n_1(order_out3),  // uint8
                         .E(Cast_out1),  // ufix10
                         .QfWEn(shortPunc_out1),
                         .remove(shortPunc_out2),  // ufix1
                         .indxOut(shortPunc_out3)  // ufix10
                         );

  sequence_rsvd u_sequence (.clk(clk),
                            .reset(reset),
                            .enb(enb),
                            .idx(Delay2_out1),  // ufix10
                            .N_1(order_out1),  // ufix10
                            .sequenceEn(Delay3_out1),
                            .sequenceRestart(Delay7_out1),
                            .shortPuncEn(Delay5_out1),
                            .K(K),  // ufix10
                            .QAddr(QAddr),  // ufix10
                            .QfWEn(shortPunc_out1),
                            .Qf(shortPunc_out2),  // ufix1
                            .QFAddr(shortPunc_out3),  // ufix10
                            .Q(sequence_out1)
                            );

  assign Q = sequence_out1;

  itlvMap u_itlvMap (.indx(itlvMap_out1),  // ufix1
                     .addr(itlvMap_out2),  // ufix1
                     .valid(itlvMap_out3)  // ufix1
                     );

  assign intlvDout = itlvMap_out1;

  assign intlvAddr = itlvMap_out2;

  assign intlvValid = itlvMap_out3;

  always @(posedge clk or posedge reset)
    begin : Delay1_process
      if (reset == 1'b1) begin
        Delay1_reg[0] <= 1'b0;
        Delay1_reg[1] <= 1'b0;
        Delay1_reg[2] <= 1'b0;
        Delay1_reg[3] <= 1'b0;
        Delay1_reg[4] <= 1'b0;
        Delay1_reg[5] <= 1'b0;
        Delay1_reg[6] <= 1'b0;
        Delay1_reg[7] <= 1'b0;
        Delay1_reg[8] <= 1'b0;
        Delay1_reg[9] <= 1'b0;
        Delay1_reg[10] <= 1'b0;
      end
      else begin
        if (enb) begin
          Delay1_reg[0] <= Delay1_reg_next[0];
          Delay1_reg[1] <= Delay1_reg_next[1];
          Delay1_reg[2] <= Delay1_reg_next[2];
          Delay1_reg[3] <= Delay1_reg_next[3];
          Delay1_reg[4] <= Delay1_reg_next[4];
          Delay1_reg[5] <= Delay1_reg_next[5];
          Delay1_reg[6] <= Delay1_reg_next[6];
          Delay1_reg[7] <= Delay1_reg_next[7];
          Delay1_reg[8] <= Delay1_reg_next[8];
          Delay1_reg[9] <= Delay1_reg_next[9];
          Delay1_reg[10] <= Delay1_reg_next[10];
        end
      end
    end

  assign Delay1_out1 = Delay1_reg[10];
  assign Delay1_reg_next[0] = configured_1;
  assign Delay1_reg_next[1] = Delay1_reg[0];
  assign Delay1_reg_next[2] = Delay1_reg[1];
  assign Delay1_reg_next[3] = Delay1_reg[2];
  assign Delay1_reg_next[4] = Delay1_reg[3];
  assign Delay1_reg_next[5] = Delay1_reg[4];
  assign Delay1_reg_next[6] = Delay1_reg[5];
  assign Delay1_reg_next[7] = Delay1_reg[6];
  assign Delay1_reg_next[8] = Delay1_reg[7];
  assign Delay1_reg_next[9] = Delay1_reg[8];
  assign Delay1_reg_next[10] = Delay1_reg[9];



  assign configured = Delay1_out1;

  assign NSub1 = order_out1;

  validateConfig u_validateConfig (.clk(clk),
                                   .reset(reset),
                                   .enb(enb),
                                   .K(K),  // ufix10
                                   .E(E),  // ufix17
                                   .configValid(validateConfig_out1)
                                   );

  assign configValid = validateConfig_out1;

endmodule  // configure

