// -------------------------------------------------------------
// 
// File Name: hdlsrc\NRPolarEncodeHDL\order.v
// Created: 2022-01-15 05:10:41
// 
// Generated by MATLAB 9.8 and HDL Coder 3.16
// 
// -------------------------------------------------------------


// -------------------------------------------------------------
// 
// Module: order
// Source Path: NRPolarEncodeHDL/HDL Algorithm/NR Polar Encoder/configure/order
// Hierarchy Level: 3
// 
// -------------------------------------------------------------

`timescale 1 ns / 1 ns

module order
          (clk,
           reset,
           enb,
           E,
           K,
           N_1,
           N,
           n_2);


  input   clk;
  input   reset;
  input   enb;
  input   [16:0] E;  // ufix17
  input   [9:0] K;  // ufix10
  output  [9:0] N_1;  // ufix10
  output  [10:0] N;  // ufix11
  output  [7:0] n_2;  // uint8


  wire [10:0] Constant_out1;  // ufix11
  wire [3:0] Constant3_out1;  // ufix4
  wire [3:0] n2;  // ufix4
  reg [9:0] Delay_out1;  // ufix10
  wire [19:0] Multiply_cast;  // ufix20_En5
  wire [13:0] Multiply_out1;  // ufix14
  reg [13:0] Delay5_out1;  // ufix14
  reg [16:0] Delay2_out1;  // ufix17
  wire [33:0] Multiply1_mul_temp;  // ufix34_En13
  wire [33:0] Multiply1_1;  // ufix34
  wire [33:0] Multiply1_2;  // ufix34
  wire [20:0] Multiply1_out1;  // ufix21
  reg [20:0] Delay6_out1;  // ufix21
  wire [20:0] Less_Than_1_1;  // ufix21
  wire Less_Than_relop1;
  reg  Delay1_out1;
  wire [12:0] Constant1_out1;  // ufix13_En3
  wire [3:0] cl2e;  // ufix4
  reg [3:0] Delay3_out1;  // ufix4
  wire Constant2_out1;  // ufix1
  wire [3:0] Subtract_sub_temp;  // ufix4
  wire [3:0] Subtract_1;  // ufix4
  wire [7:0] Subtract_out1;  // uint8
  wire [12:0] Shift_Arithmetic_out1;  // ufix13_En3
  wire [19:0] Less_Than1_1_cast;  // ufix20_En3
  wire [19:0] Less_Than1_1_cast_1;  // ufix20_En3
  wire Less_Than1_relop1;
  reg  [0:2] Delay7_reg;  // ufix1 [3]
  wire [0:2] Delay7_reg_next;  // ufix1 [3]
  wire Delay7_out1;
  wire AND_out1;
  reg [3:0] Delay9_reg [0:1];  // ufix4 [2]
  wire [3:0] Delay9_reg_next [0:1];  // ufix4 [2]
  wire [3:0] Delay9_out1;  // ufix4
  wire [7:0] Delay9_out1_dtc;  // uint8
  reg [7:0] Delay8_reg [0:1];  // ufix8 [2]
  wire [7:0] Delay8_reg_next [0:1];  // ufix8 [2]
  wire [7:0] Delay8_out1;  // uint8
  wire [7:0] n1;  // uint8
  reg [3:0] Delay10_reg [0:3];  // ufix4 [4]
  wire [3:0] Delay10_reg_next [0:3];  // ufix4 [4]
  wire [3:0] n2_1;  // ufix4
  wire [7:0] Min_op_stage1;  // ufix8
  reg [7:0] Delay4_out1;  // uint8
  wire [7:0] Min_op_stage2;  // ufix8
  wire [7:0] Min_out1;  // uint8
  reg [7:0] Delay11_out1;  // uint8
  wire [10:0] Shift_Arithmetic1_out1;  // ufix11
  wire Constant4_out1;  // ufix1
  wire signed [31:0] Subtract1_sub_temp;  // sfix32
  wire signed [31:0] Subtract1_1;  // sfix32
  wire signed [31:0] Subtract1_2;  // sfix32
  wire [9:0] Subtract1_out1;  // ufix10
  reg [9:0] Delay12_out1;  // ufix10
  reg [10:0] Delay14_out1;  // ufix11
  reg [7:0] Delay13_out1;  // uint8


  assign Constant_out1 = 11'b00000000001;



  assign Constant3_out1 = 4'b1010;



  ceilLog2K u_ceilLog2K (.K(K),  // ufix10
                         .nMax(Constant3_out1),  // ufix4
                         .n2(n2)  // ufix4
                         );

  always @(posedge clk or posedge reset)
    begin : Delay_process
      if (reset == 1'b1) begin
        Delay_out1 <= 10'b0000000000;
      end
      else begin
        if (enb) begin
          Delay_out1 <= K;
        end
      end
    end



  assign Multiply_cast = {1'b0, {Delay_out1, 9'b000000000}};
  assign Multiply_out1 = Multiply_cast[18:5];



  always @(posedge clk or posedge reset)
    begin : Delay5_process
      if (reset == 1'b1) begin
        Delay5_out1 <= 14'b00000000000000;
      end
      else begin
        if (enb) begin
          Delay5_out1 <= Multiply_out1;
        end
      end
    end



  always @(posedge clk or posedge reset)
    begin : Delay2_process
      if (reset == 1'b1) begin
        Delay2_out1 <= 17'b00000000000000000;
      end
      else begin
        if (enb) begin
          Delay2_out1 <= E;
        end
      end
    end



  // CSD Encoding (73728) : 010010000000000000; Cost (Adders) = 1
  assign Multiply1_1 = {1'b0, {Delay2_out1, 16'b0000000000000000}};
  assign Multiply1_2 = {4'b0, {Delay2_out1, 13'b0000000000000}};
  assign Multiply1_mul_temp = Multiply1_1 + Multiply1_2;
  assign Multiply1_out1 = Multiply1_mul_temp[33:13];



  always @(posedge clk or posedge reset)
    begin : Delay6_process
      if (reset == 1'b1) begin
        Delay6_out1 <= 21'b000000000000000000000;
      end
      else begin
        if (enb) begin
          Delay6_out1 <= Multiply1_out1;
        end
      end
    end



  assign Less_Than_1_1 = {7'b0, Delay5_out1};
  assign Less_Than_relop1 = Less_Than_1_1 < Delay6_out1;



  always @(posedge clk or posedge reset)
    begin : Delay1_process
      if (reset == 1'b1) begin
        Delay1_out1 <= 1'b0;
      end
      else begin
        if (enb) begin
          Delay1_out1 <= Less_Than_relop1;
        end
      end
    end



  assign Constant1_out1 = 13'b0000000001001;



  ceilLog2E u_ceilLog2E (.E(E),  // ufix17
                         .nMax(Constant3_out1),  // ufix4
                         .cl2e(cl2e)  // ufix4
                         );

  always @(posedge clk or posedge reset)
    begin : Delay3_process
      if (reset == 1'b1) begin
        Delay3_out1 <= 4'b0000;
      end
      else begin
        if (enb) begin
          Delay3_out1 <= cl2e;
        end
      end
    end



  assign Constant2_out1 = 1'b1;



  assign Subtract_1 = {3'b0, Constant2_out1};
  assign Subtract_sub_temp = Delay3_out1 - Subtract_1;
  assign Subtract_out1 = {4'b0, Subtract_sub_temp};



  assign Shift_Arithmetic_out1 = Constant1_out1 <<< Subtract_out1;



  assign Less_Than1_1_cast = {E, 3'b000};
  assign Less_Than1_1_cast_1 = {7'b0, Shift_Arithmetic_out1};
  assign Less_Than1_relop1 = Less_Than1_1_cast <= Less_Than1_1_cast_1;



  always @(posedge clk or posedge reset)
    begin : Delay7_process
      if (reset == 1'b1) begin
        Delay7_reg[0] <= 1'b0;
        Delay7_reg[1] <= 1'b0;
        Delay7_reg[2] <= 1'b0;
      end
      else begin
        if (enb) begin
          Delay7_reg[0] <= Delay7_reg_next[0];
          Delay7_reg[1] <= Delay7_reg_next[1];
          Delay7_reg[2] <= Delay7_reg_next[2];
        end
      end
    end

  assign Delay7_out1 = Delay7_reg[2];
  assign Delay7_reg_next[0] = Less_Than1_relop1;
  assign Delay7_reg_next[1] = Delay7_reg[0];
  assign Delay7_reg_next[2] = Delay7_reg[1];



  assign AND_out1 = Delay1_out1 & Delay7_out1;



  always @(posedge clk or posedge reset)
    begin : Delay9_process
      if (reset == 1'b1) begin
        Delay9_reg[0] <= 4'b0000;
        Delay9_reg[1] <= 4'b0000;
      end
      else begin
        if (enb) begin
          Delay9_reg[0] <= Delay9_reg_next[0];
          Delay9_reg[1] <= Delay9_reg_next[1];
        end
      end
    end

  assign Delay9_out1 = Delay9_reg[1];
  assign Delay9_reg_next[0] = Delay3_out1;
  assign Delay9_reg_next[1] = Delay9_reg[0];



  assign Delay9_out1_dtc = {4'b0, Delay9_out1};



  always @(posedge clk or posedge reset)
    begin : Delay8_process
      if (reset == 1'b1) begin
        Delay8_reg[0] <= 8'b00000000;
        Delay8_reg[1] <= 8'b00000000;
      end
      else begin
        if (enb) begin
          Delay8_reg[0] <= Delay8_reg_next[0];
          Delay8_reg[1] <= Delay8_reg_next[1];
        end
      end
    end

  assign Delay8_out1 = Delay8_reg[1];
  assign Delay8_reg_next[0] = Subtract_out1;
  assign Delay8_reg_next[1] = Delay8_reg[0];



  assign n1 = (AND_out1 == 1'b0 ? Delay9_out1_dtc :
              Delay8_out1);



  always @(posedge clk or posedge reset)
    begin : Delay10_process
      if (reset == 1'b1) begin
        Delay10_reg[0] <= 4'b0000;
        Delay10_reg[1] <= 4'b0000;
        Delay10_reg[2] <= 4'b0000;
        Delay10_reg[3] <= 4'b0000;
      end
      else begin
        if (enb) begin
          Delay10_reg[0] <= Delay10_reg_next[0];
          Delay10_reg[1] <= Delay10_reg_next[1];
          Delay10_reg[2] <= Delay10_reg_next[2];
          Delay10_reg[3] <= Delay10_reg_next[3];
        end
      end
    end

  assign n2_1 = Delay10_reg[3];
  assign Delay10_reg_next[0] = n2;
  assign Delay10_reg_next[1] = Delay10_reg[0];
  assign Delay10_reg_next[2] = Delay10_reg[1];
  assign Delay10_reg_next[3] = Delay10_reg[2];



  assign Min_op_stage1 = {4'b0, n2_1};



  always @(posedge clk or posedge reset)
    begin : Delay4_process
      if (reset == 1'b1) begin
        Delay4_out1 <= 8'b00000000;
      end
      else begin
        if (enb) begin
          Delay4_out1 <= n1;
        end
      end
    end



  assign Min_op_stage2 = Delay4_out1;



  Min u_Min (.in0(Min_op_stage1),  // ufix8
             .in1(Min_op_stage2),  // ufix8
             .out0(Min_out1)  // uint8
             );

  always @(posedge clk or posedge reset)
    begin : Delay11_process
      if (reset == 1'b1) begin
        Delay11_out1 <= 8'b00000000;
      end
      else begin
        if (enb) begin
          Delay11_out1 <= Min_out1;
        end
      end
    end



  assign Shift_Arithmetic1_out1 = Constant_out1 <<< Delay11_out1;



  assign Constant4_out1 = 1'b1;



  assign Subtract1_1 = {21'b0, Shift_Arithmetic1_out1};
  assign Subtract1_2 = {31'b0, Constant4_out1};
  assign Subtract1_sub_temp = Subtract1_1 - Subtract1_2;
  assign Subtract1_out1 = Subtract1_sub_temp[9:0];



  always @(posedge clk or posedge reset)
    begin : Delay12_process
      if (reset == 1'b1) begin
        Delay12_out1 <= 10'b0000000000;
      end
      else begin
        if (enb) begin
          Delay12_out1 <= Subtract1_out1;
        end
      end
    end



  assign N_1 = Delay12_out1;

  always @(posedge clk or posedge reset)
    begin : Delay14_process
      if (reset == 1'b1) begin
        Delay14_out1 <= 11'b00000000000;
      end
      else begin
        if (enb) begin
          Delay14_out1 <= Shift_Arithmetic1_out1;
        end
      end
    end



  assign N = Delay14_out1;

  always @(posedge clk or posedge reset)
    begin : Delay13_process
      if (reset == 1'b1) begin
        Delay13_out1 <= 8'b00000000;
      end
      else begin
        if (enb) begin
          Delay13_out1 <= Delay11_out1;
        end
      end
    end



  assign n_2 = Delay13_out1;

endmodule  // order

